{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"align/","text":"Alignment Functions NextGenSeqUtils.align_reference_frames NextGenSeqUtils.banded_nw_align NextGenSeqUtils.kmer_seeded_align NextGenSeqUtils.kmer_seeded_edit_dist NextGenSeqUtils.loc_kmer_seeded_align NextGenSeqUtils.local_align NextGenSeqUtils.local_edit_dist NextGenSeqUtils.local_kmer_seeded_align NextGenSeqUtils.nw_align NextGenSeqUtils.resolve_alignments NextGenSeqUtils.triplet_kmer_seeded_align NextGenSeqUtils.triplet_nw_align # NextGenSeqUtils.nw_align Function . nw_align(s1::String, s2::String; edge_reduction = 0.99) Returns aligned strings using the Needleman-Wunch Algorithm (quadratic), with end gaps penalized slightly less. edge_reduction is a multiplier (usually less than one) on gaps on end of strings. source nw_align(s1::String, s2::String, banded::Float64) Wrapper for nw_align and banded_nw_align . A larger banded value makes alignment slower but more accurate. source # NextGenSeqUtils.banded_nw_align Function . banded_nw_align(s1::String, s2::String; edge_reduction = 0.99, band_coeff = 1) Like nw_align, but sub quadratic by only computing values within a band around the center diagonal. One 'band' of radius 3 = (4,1), (3,1), (2,1), (1,1), (1,2), (1,3), (1,4), aka upside-down L shape. band_coeff = 1 is sufficient to get same alignments as nw_align for 10% diverged sequences ~97% of the time; increase this value for more conservative alignment with longer computation time. Radius of band = bandwidth = band_coeff * sqrt(avg seq length) source # NextGenSeqUtils.triplet_nw_align Function . triplet_nw_align(s1::String, s2::String; edge_reduction = 0.99, boundary_mult = 2) Returns alignment of two sequences where s1 is a reference with reading frame to be preserved and s2 is a query sequence. boundary_mult adjusts penalties for gaps preserving the reading frame of s1 . This usually works best on range 0 to 3, higher values for more strongly enforced gaps aligned on reference frame (divisible-by-3 indices) source # NextGenSeqUtils.local_align Function . local_align(ref::String, query::String; mismatch_score = -1, match_score = 1, gap_penalty = -1, rightaligned=true, refend = false) Aligns a query sequence locally to a reference. If true, rightaligned keeps the right ends of each sequence in final alignment- otherwise they are trimmed; refend keeps the beginning/left end of ref . If you want to keep both ends of both strings, use nw_align. For best alignments use the default score values. source # NextGenSeqUtils.kmer_seeded_align Function . kmer_seeded_align(s1::String, s2::String; wordlength = 30, skip = 10, aligncodons = false, banded = 1.0, debug::Bool = false) Returns aligned strings, where alignment is first done with larger word matches and then (possibly banded) Needleman-Wunsch on intermediate intervals. skip gives a necessary gap between searched-for words in s1 . For best results, use the default wordlength and skip values. See nw_align for explanation of banded . source # NextGenSeqUtils.triplet_kmer_seeded_align Function . triplet_kmer_seeded_align(s1::String, s2::String; wordlength = 30, skip = 9, boundary_mult = 2, alignedcodons = true, debug::Bool=false) Returns aligned strings, where alignment is first done with word matches and then Needleman-Wunsch on intermediate intervals, prefering to preserve the reading frame of the first arg s1 . skip gives a necessary gap between searched-for words in s1 . For best results, use the default wordlength and skip values. See triplet_nw_align for explanation of boundary_mult . source # NextGenSeqUtils.loc_kmer_seeded_align Function . function local_kmer_seeded_align(s1::String, s2::String; wordlength = 30, skip = 10, trimpadding = 100, debug::Bool=false) Returns locally aligned strings, where alignment is first done with word matches and then Needleman-Wunsch on intermediate intervals. s1 is a reference to align to, and s2 is a query to extract a local match from. s2 may be trimmed or expanded with gaps. Before locally aligning ends of sequences, the ends of s2 are trimmed to length trimpadding for faster alignment. Increasing this will possible increase alignment accuracy but effect runtime. skip gives a necessary gap between searched-for words in s1 . For best results, use the default wordlength and skip values. source # NextGenSeqUtils.local_kmer_seeded_align Function . function local_kmer_seeded_align(s1::String, s2::String; wordlength = 30, skip = 10, trimpadding = 100, debug::Bool=false) Returns locally aligned strings, where alignment is first done with word matches and then Needleman-Wunsch on intermediate intervals. s1 is a reference to align to, and s2 is a query to extract a local match from. s2 may be trimmed or expanded with gaps. Before locally aligning ends of sequences, the ends of s2 are trimmed to length trimpadding for faster alignment. Increasing this will possible increase alignment accuracy but effect runtime. skip gives a necessary gap between searched-for words in s1 . For best results, use the default wordlength and skip values. source # NextGenSeqUtils.kmer_seeded_edit_dist Function . kmer_seeded_edit_dist(s1::String , s2::String; wordlength = 30, skip = 5, aa_matches = false) Computes levenshtein edit distance with speedups from only computing the dp scoring matrix between word matches. If aa_matches = true, will attempt to find amino acid matches in any reference frame, and add the nucleotide Hamming distance of these matches to Levenshtein distances of mismatches. skip gives a necessary gap between searched-for words in s1 . For best results, use the default wordlength and skip values. source # NextGenSeqUtils.resolve_alignments Function . resolve_alignments(ref::String, query::String; mode = 1) Called on aligned strings. Resolves query with respect to ref . mode = 1 for resolving single indels, mode = 2 for resolving single indels and codon insertions in query. source # NextGenSeqUtils.align_reference_frames Function . align_reading_frames(clusters; k = 6, thresh = 0.03, verbose = false) Takes clusters = [consensus_sequences, cluster_sizes], chooses references out of consensuses that do not have stop codons in the middle, and makes all consensus sequence reading frames agree. Returns resolved consensus seqs ( goods ) along with filtered out consensus seqs that are thresh divergent from nearest reference ( bads ). k = kmer size for computing kmer vectors of sequences. source # NextGenSeqUtils.local_edit_dist Function . local_edit_dist(s1::String, s2::String) Returns the edit distance between two sequences after local alignment source","title":"Align"},{"location":"align/#alignment-functions","text":"NextGenSeqUtils.align_reference_frames NextGenSeqUtils.banded_nw_align NextGenSeqUtils.kmer_seeded_align NextGenSeqUtils.kmer_seeded_edit_dist NextGenSeqUtils.loc_kmer_seeded_align NextGenSeqUtils.local_align NextGenSeqUtils.local_edit_dist NextGenSeqUtils.local_kmer_seeded_align NextGenSeqUtils.nw_align NextGenSeqUtils.resolve_alignments NextGenSeqUtils.triplet_kmer_seeded_align NextGenSeqUtils.triplet_nw_align # NextGenSeqUtils.nw_align Function . nw_align(s1::String, s2::String; edge_reduction = 0.99) Returns aligned strings using the Needleman-Wunch Algorithm (quadratic), with end gaps penalized slightly less. edge_reduction is a multiplier (usually less than one) on gaps on end of strings. source nw_align(s1::String, s2::String, banded::Float64) Wrapper for nw_align and banded_nw_align . A larger banded value makes alignment slower but more accurate. source # NextGenSeqUtils.banded_nw_align Function . banded_nw_align(s1::String, s2::String; edge_reduction = 0.99, band_coeff = 1) Like nw_align, but sub quadratic by only computing values within a band around the center diagonal. One 'band' of radius 3 = (4,1), (3,1), (2,1), (1,1), (1,2), (1,3), (1,4), aka upside-down L shape. band_coeff = 1 is sufficient to get same alignments as nw_align for 10% diverged sequences ~97% of the time; increase this value for more conservative alignment with longer computation time. Radius of band = bandwidth = band_coeff * sqrt(avg seq length) source # NextGenSeqUtils.triplet_nw_align Function . triplet_nw_align(s1::String, s2::String; edge_reduction = 0.99, boundary_mult = 2) Returns alignment of two sequences where s1 is a reference with reading frame to be preserved and s2 is a query sequence. boundary_mult adjusts penalties for gaps preserving the reading frame of s1 . This usually works best on range 0 to 3, higher values for more strongly enforced gaps aligned on reference frame (divisible-by-3 indices) source # NextGenSeqUtils.local_align Function . local_align(ref::String, query::String; mismatch_score = -1, match_score = 1, gap_penalty = -1, rightaligned=true, refend = false) Aligns a query sequence locally to a reference. If true, rightaligned keeps the right ends of each sequence in final alignment- otherwise they are trimmed; refend keeps the beginning/left end of ref . If you want to keep both ends of both strings, use nw_align. For best alignments use the default score values. source # NextGenSeqUtils.kmer_seeded_align Function . kmer_seeded_align(s1::String, s2::String; wordlength = 30, skip = 10, aligncodons = false, banded = 1.0, debug::Bool = false) Returns aligned strings, where alignment is first done with larger word matches and then (possibly banded) Needleman-Wunsch on intermediate intervals. skip gives a necessary gap between searched-for words in s1 . For best results, use the default wordlength and skip values. See nw_align for explanation of banded . source # NextGenSeqUtils.triplet_kmer_seeded_align Function . triplet_kmer_seeded_align(s1::String, s2::String; wordlength = 30, skip = 9, boundary_mult = 2, alignedcodons = true, debug::Bool=false) Returns aligned strings, where alignment is first done with word matches and then Needleman-Wunsch on intermediate intervals, prefering to preserve the reading frame of the first arg s1 . skip gives a necessary gap between searched-for words in s1 . For best results, use the default wordlength and skip values. See triplet_nw_align for explanation of boundary_mult . source # NextGenSeqUtils.loc_kmer_seeded_align Function . function local_kmer_seeded_align(s1::String, s2::String; wordlength = 30, skip = 10, trimpadding = 100, debug::Bool=false) Returns locally aligned strings, where alignment is first done with word matches and then Needleman-Wunsch on intermediate intervals. s1 is a reference to align to, and s2 is a query to extract a local match from. s2 may be trimmed or expanded with gaps. Before locally aligning ends of sequences, the ends of s2 are trimmed to length trimpadding for faster alignment. Increasing this will possible increase alignment accuracy but effect runtime. skip gives a necessary gap between searched-for words in s1 . For best results, use the default wordlength and skip values. source # NextGenSeqUtils.local_kmer_seeded_align Function . function local_kmer_seeded_align(s1::String, s2::String; wordlength = 30, skip = 10, trimpadding = 100, debug::Bool=false) Returns locally aligned strings, where alignment is first done with word matches and then Needleman-Wunsch on intermediate intervals. s1 is a reference to align to, and s2 is a query to extract a local match from. s2 may be trimmed or expanded with gaps. Before locally aligning ends of sequences, the ends of s2 are trimmed to length trimpadding for faster alignment. Increasing this will possible increase alignment accuracy but effect runtime. skip gives a necessary gap between searched-for words in s1 . For best results, use the default wordlength and skip values. source # NextGenSeqUtils.kmer_seeded_edit_dist Function . kmer_seeded_edit_dist(s1::String , s2::String; wordlength = 30, skip = 5, aa_matches = false) Computes levenshtein edit distance with speedups from only computing the dp scoring matrix between word matches. If aa_matches = true, will attempt to find amino acid matches in any reference frame, and add the nucleotide Hamming distance of these matches to Levenshtein distances of mismatches. skip gives a necessary gap between searched-for words in s1 . For best results, use the default wordlength and skip values. source # NextGenSeqUtils.resolve_alignments Function . resolve_alignments(ref::String, query::String; mode = 1) Called on aligned strings. Resolves query with respect to ref . mode = 1 for resolving single indels, mode = 2 for resolving single indels and codon insertions in query. source # NextGenSeqUtils.align_reference_frames Function . align_reading_frames(clusters; k = 6, thresh = 0.03, verbose = false) Takes clusters = [consensus_sequences, cluster_sizes], chooses references out of consensuses that do not have stop codons in the middle, and makes all consensus sequence reading frames agree. Returns resolved consensus seqs ( goods ) along with filtered out consensus seqs that are thresh divergent from nearest reference ( bads ). k = kmer size for computing kmer vectors of sequences. source # NextGenSeqUtils.local_edit_dist Function . local_edit_dist(s1::String, s2::String) Returns the edit distance between two sequences after local alignment source","title":"Alignment Functions"},{"location":"hmm/","text":"Hidden Markov Model Functions NextGenSeqUtils.backward_logs NextGenSeqUtils.forward_backward_logs NextGenSeqUtils.forward_logs NextGenSeqUtils.gen_seq_with_model NextGenSeqUtils.get_obs_given_state NextGenSeqUtils.homopolymer_filter NextGenSeqUtils.initial_dist NextGenSeqUtils.logsum NextGenSeqUtils.markov_filter NextGenSeqUtils.obs_mat NextGenSeqUtils.trans_mat NextGenSeqUtils.viterbi_logs NextGenSeqUtils.viterbiprint # NextGenSeqUtils.viterbi_logs Function . viterbi_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64}) Return viterbi path and log probability for that path. Takes logs of matrices. observations_given_states has # rows = # states, # columns = # steps of markov process. source # NextGenSeqUtils.trans_mat Function . trans_mat(; uniform_cycle_prob = 0.9999999999, homopoly_cycle_prob = 0.98) Return 5x5 transition matrix with given transition probabilities State 1 \u2013 uniform observation distribution. State 2 \u2013 High \"A\" observation likelihood. State 3 \u2013 High \"C\" observation likelihood. State 4 \u2013 High \"G\" observation likelihood. State 5 \u2013 High \"T\" observation likelihood. Each state has high likelihood to return to state 1. States 2 through 5 represent high likelihood of homopolymer regions of respective nuc. source # NextGenSeqUtils.obs_mat Function . obs_mat(; homopoly_prob = 0.99) Return 5x4 observation matrix with given probabilities. State 1 \u2013 uniform observation distribution. State 2 \u2013 High \"A\" observation likelihood. State 3 \u2013 High \"C\" observation likelihood. State 4 \u2013 High \"G\" observation likelihood. State 5 \u2013 High \"T\" observation likelihood. Columns are in same order as columns 2 through 5 (the last four rows give a symmetric matrix). source # NextGenSeqUtils.initial_dist Function . initial_dist(; uniform_state = 0.99) Initial state distributions: see trans_mat for state descriptions. 5x1 vector. source # NextGenSeqUtils.get_obs_given_state Function . get_obs_given_state(observation_matrix::Array{Float64,2}, observation_seq::String) Populate 5xT matrix with likelihood of observation at each of T time steps given each nucleotide in observation_seq . source # NextGenSeqUtils.homopolymer_filter Function . homopolymer_filter(seqs::Array{String,1}, phreds, names; transmat = nothing, obsmat = nothing, initialdist = nothing) Filter sequences with \"bad\" sections in the middle \u2013 abnormally long runs of a single base, using viterbi alg inference. If this homopolymer occurs on one end of a sequence, keeps sequence and trims homopolymer region off end. phreds and/or names may be nothing , in which case nothing is returned for the respective field. If transition, observation, initial distribution matrices not provided (default) then the default values from the respective constructors are used. source homopolymer_filter(sourcepath::String, destpath::String; transmat = nothing, obsmat = nothing, initialdist = nothing, format= fastq ) Filter sequences with \"bad\" sections in the middle \u2013 abnormally long runs of a single base, using viterbi alg inference. If this homopolymer occurs on one end of a sequence, keeps sequence and trims homopolymer region off end. Takes a file path for each of a source file of type format (which may be \"fasta\" or \"fastq\") and a destination file is written which is the same file type. source # NextGenSeqUtils.markov_filter Function . homopolymer_filter(seqs::Array{String,1}, phreds, names; transmat = nothing, obsmat = nothing, initialdist = nothing) Filter sequences with \"bad\" sections in the middle \u2013 abnormally long runs of a single base, using viterbi alg inference. If this homopolymer occurs on one end of a sequence, keeps sequence and trims homopolymer region off end. phreds and/or names may be nothing , in which case nothing is returned for the respective field. If transition, observation, initial distribution matrices not provided (default) then the default values from the respective constructors are used. source homopolymer_filter(sourcepath::String, destpath::String; transmat = nothing, obsmat = nothing, initialdist = nothing, format= fastq ) Filter sequences with \"bad\" sections in the middle \u2013 abnormally long runs of a single base, using viterbi alg inference. If this homopolymer occurs on one end of a sequence, keeps sequence and trims homopolymer region off end. Takes a file path for each of a source file of type format (which may be \"fasta\" or \"fastq\") and a destination file is written which is the same file type. source # NextGenSeqUtils.forward_logs Function . forward_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64}) Compute logs of forward scores. Takes logs of matrices as inputs. observations_given_states has # rows = # states, # columns = # steps of markov process. source # NextGenSeqUtils.backward_logs Function . backward_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64}) Compute logs of backward scores and individual posterior probabilities. Takes logs of matrices as inputs. observations_given_states has # rows = # states, # columns = # steps of markov process. source # NextGenSeqUtils.forward_backward_logs Function . forward_backward_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64}) Compute logs of forward-backward scores and individual probabilities. Takes logs of matrices as inputs. observations_given_states has # rows = # states, # columns = # steps of markov process. source # NextGenSeqUtils.logsum Function . logsum(lga, lgb) Compute numerically stable logsum. Returns -Inf if either input is -Inf . source # NextGenSeqUtils.gen_seq_with_model Function . gen_seq_with_model(n::Int, trans_mat, obs_mat, initial_dists) Generate a sequence given a markov model. May create bad reads (long runs of a single base). source # NextGenSeqUtils.viterbiprint Function . viterbiprint(s::String) Draw flagged sites with capital letters, safe sites with lowercase. source","title":"hmm"},{"location":"hmm/#hidden-markov-model-functions","text":"NextGenSeqUtils.backward_logs NextGenSeqUtils.forward_backward_logs NextGenSeqUtils.forward_logs NextGenSeqUtils.gen_seq_with_model NextGenSeqUtils.get_obs_given_state NextGenSeqUtils.homopolymer_filter NextGenSeqUtils.initial_dist NextGenSeqUtils.logsum NextGenSeqUtils.markov_filter NextGenSeqUtils.obs_mat NextGenSeqUtils.trans_mat NextGenSeqUtils.viterbi_logs NextGenSeqUtils.viterbiprint # NextGenSeqUtils.viterbi_logs Function . viterbi_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64}) Return viterbi path and log probability for that path. Takes logs of matrices. observations_given_states has # rows = # states, # columns = # steps of markov process. source # NextGenSeqUtils.trans_mat Function . trans_mat(; uniform_cycle_prob = 0.9999999999, homopoly_cycle_prob = 0.98) Return 5x5 transition matrix with given transition probabilities State 1 \u2013 uniform observation distribution. State 2 \u2013 High \"A\" observation likelihood. State 3 \u2013 High \"C\" observation likelihood. State 4 \u2013 High \"G\" observation likelihood. State 5 \u2013 High \"T\" observation likelihood. Each state has high likelihood to return to state 1. States 2 through 5 represent high likelihood of homopolymer regions of respective nuc. source # NextGenSeqUtils.obs_mat Function . obs_mat(; homopoly_prob = 0.99) Return 5x4 observation matrix with given probabilities. State 1 \u2013 uniform observation distribution. State 2 \u2013 High \"A\" observation likelihood. State 3 \u2013 High \"C\" observation likelihood. State 4 \u2013 High \"G\" observation likelihood. State 5 \u2013 High \"T\" observation likelihood. Columns are in same order as columns 2 through 5 (the last four rows give a symmetric matrix). source # NextGenSeqUtils.initial_dist Function . initial_dist(; uniform_state = 0.99) Initial state distributions: see trans_mat for state descriptions. 5x1 vector. source # NextGenSeqUtils.get_obs_given_state Function . get_obs_given_state(observation_matrix::Array{Float64,2}, observation_seq::String) Populate 5xT matrix with likelihood of observation at each of T time steps given each nucleotide in observation_seq . source # NextGenSeqUtils.homopolymer_filter Function . homopolymer_filter(seqs::Array{String,1}, phreds, names; transmat = nothing, obsmat = nothing, initialdist = nothing) Filter sequences with \"bad\" sections in the middle \u2013 abnormally long runs of a single base, using viterbi alg inference. If this homopolymer occurs on one end of a sequence, keeps sequence and trims homopolymer region off end. phreds and/or names may be nothing , in which case nothing is returned for the respective field. If transition, observation, initial distribution matrices not provided (default) then the default values from the respective constructors are used. source homopolymer_filter(sourcepath::String, destpath::String; transmat = nothing, obsmat = nothing, initialdist = nothing, format= fastq ) Filter sequences with \"bad\" sections in the middle \u2013 abnormally long runs of a single base, using viterbi alg inference. If this homopolymer occurs on one end of a sequence, keeps sequence and trims homopolymer region off end. Takes a file path for each of a source file of type format (which may be \"fasta\" or \"fastq\") and a destination file is written which is the same file type. source # NextGenSeqUtils.markov_filter Function . homopolymer_filter(seqs::Array{String,1}, phreds, names; transmat = nothing, obsmat = nothing, initialdist = nothing) Filter sequences with \"bad\" sections in the middle \u2013 abnormally long runs of a single base, using viterbi alg inference. If this homopolymer occurs on one end of a sequence, keeps sequence and trims homopolymer region off end. phreds and/or names may be nothing , in which case nothing is returned for the respective field. If transition, observation, initial distribution matrices not provided (default) then the default values from the respective constructors are used. source homopolymer_filter(sourcepath::String, destpath::String; transmat = nothing, obsmat = nothing, initialdist = nothing, format= fastq ) Filter sequences with \"bad\" sections in the middle \u2013 abnormally long runs of a single base, using viterbi alg inference. If this homopolymer occurs on one end of a sequence, keeps sequence and trims homopolymer region off end. Takes a file path for each of a source file of type format (which may be \"fasta\" or \"fastq\") and a destination file is written which is the same file type. source # NextGenSeqUtils.forward_logs Function . forward_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64}) Compute logs of forward scores. Takes logs of matrices as inputs. observations_given_states has # rows = # states, # columns = # steps of markov process. source # NextGenSeqUtils.backward_logs Function . backward_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64}) Compute logs of backward scores and individual posterior probabilities. Takes logs of matrices as inputs. observations_given_states has # rows = # states, # columns = # steps of markov process. source # NextGenSeqUtils.forward_backward_logs Function . forward_backward_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64}) Compute logs of forward-backward scores and individual probabilities. Takes logs of matrices as inputs. observations_given_states has # rows = # states, # columns = # steps of markov process. source # NextGenSeqUtils.logsum Function . logsum(lga, lgb) Compute numerically stable logsum. Returns -Inf if either input is -Inf . source # NextGenSeqUtils.gen_seq_with_model Function . gen_seq_with_model(n::Int, trans_mat, obs_mat, initial_dists) Generate a sequence given a markov model. May create bad reads (long runs of a single base). source # NextGenSeqUtils.viterbiprint Function . viterbiprint(s::String) Draw flagged sites with capital letters, safe sites with lowercase. source","title":"Hidden Markov Model Functions"},{"location":"io/","text":"IO Functions NextGenSeqUtils.read_fasta NextGenSeqUtils.read_fasta_with_names NextGenSeqUtils.read_fasta_with_names_in_other_order NextGenSeqUtils.read_fastq NextGenSeqUtils.write_fasta NextGenSeqUtils.write_fastq # NextGenSeqUtils.read_fasta Function . read_fasta(filename; seqtype=String) Read .fasta file contents, parse, and return sequences as type seqtype source # NextGenSeqUtils.read_fasta_with_names Function . read_fasta_with_names(filename; seqtype=String) Read .fasta file contents, parse, and return names and sequences as type seqtype . source # NextGenSeqUtils.read_fasta_with_names_in_other_order Function . read_fasta_with_names_in_other_order(filename; seqtype=String) Read .fasta file contents, parse, and return sequences as type seqtype with names. Now that's what I call convenience. source # NextGenSeqUtils.write_fasta Function . write_fasta(filename::String, seqs; names = String[]) Write given seqs and optional names to a .fasta file with given filepath. source # NextGenSeqUtils.read_fastq Function . read_fastq(filename; seqtype=String) Read .fastq file contents, parse, and return sequences as seqtype type, phreds, and names. source # NextGenSeqUtils.write_fastq Function . write_fastq(filename, seqs, phreds::Vector{Vector{Phred}}; names=String[], DNASeqType = false) Write given sequences, phreds, names to .fastq file with given file path. If names not provided, gives names 'seq_1', etc. source","title":"io"},{"location":"io/#io-functions","text":"NextGenSeqUtils.read_fasta NextGenSeqUtils.read_fasta_with_names NextGenSeqUtils.read_fasta_with_names_in_other_order NextGenSeqUtils.read_fastq NextGenSeqUtils.write_fasta NextGenSeqUtils.write_fastq # NextGenSeqUtils.read_fasta Function . read_fasta(filename; seqtype=String) Read .fasta file contents, parse, and return sequences as type seqtype source # NextGenSeqUtils.read_fasta_with_names Function . read_fasta_with_names(filename; seqtype=String) Read .fasta file contents, parse, and return names and sequences as type seqtype . source # NextGenSeqUtils.read_fasta_with_names_in_other_order Function . read_fasta_with_names_in_other_order(filename; seqtype=String) Read .fasta file contents, parse, and return sequences as type seqtype with names. Now that's what I call convenience. source # NextGenSeqUtils.write_fasta Function . write_fasta(filename::String, seqs; names = String[]) Write given seqs and optional names to a .fasta file with given filepath. source # NextGenSeqUtils.read_fastq Function . read_fastq(filename; seqtype=String) Read .fastq file contents, parse, and return sequences as seqtype type, phreds, and names. source # NextGenSeqUtils.write_fastq Function . write_fastq(filename, seqs, phreds::Vector{Vector{Phred}}; names=String[], DNASeqType = false) Write given sequences, phreds, names to .fastq file with given file path. If names not provided, gives names 'seq_1', etc. source","title":"IO Functions"},{"location":"kmers/","text":"Kmer Vector Functions NextGenSeqUtils.corrected_kmer_dist NextGenSeqUtils.kmer_count NextGenSeqUtils.sparse_aa_kmer_count # NextGenSeqUtils.kmer_count Function . kmer_count(str::String, k::Int) Count kmers of size k in string, return array with bins from \"A...A\" to \"T...T\" and value in each bin corresponding to number of occurences of that kmer within str . source # NextGenSeqUtils.sparse_aa_kmer_count Function . sparse_aa_kmer_count(str::String, k::Int) Counts amino acid kmers in string (in all reading frames). k = length of kmer in amino acids. This is sparse and kinda slow. source # NextGenSeqUtils.corrected_kmer_dist Function . corrected_kmer_dist(kmers1::Array, kmers2::Array; k = nothing) Compute distance between kmer vectors that is corrected towards edit distance for small differences. The default for k is k = Int(log(4, length(kmers1))) source corrected_kmer_dist(k::Int) Returns function that computes distance between k -mer vectors that is corrected towards edit distance for small differences. source","title":"kmers"},{"location":"kmers/#kmer-vector-functions","text":"NextGenSeqUtils.corrected_kmer_dist NextGenSeqUtils.kmer_count NextGenSeqUtils.sparse_aa_kmer_count # NextGenSeqUtils.kmer_count Function . kmer_count(str::String, k::Int) Count kmers of size k in string, return array with bins from \"A...A\" to \"T...T\" and value in each bin corresponding to number of occurences of that kmer within str . source # NextGenSeqUtils.sparse_aa_kmer_count Function . sparse_aa_kmer_count(str::String, k::Int) Counts amino acid kmers in string (in all reading frames). k = length of kmer in amino acids. This is sparse and kinda slow. source # NextGenSeqUtils.corrected_kmer_dist Function . corrected_kmer_dist(kmers1::Array, kmers2::Array; k = nothing) Compute distance between kmer vectors that is corrected towards edit distance for small differences. The default for k is k = Int(log(4, length(kmers1))) source corrected_kmer_dist(k::Int) Returns function that computes distance between k -mer vectors that is corrected towards edit distance for small differences. source","title":"Kmer Vector Functions"},{"location":"orient/","text":"Sequence Orienting Functions NextGenSeqUtils.orient_strands NextGenSeqUtils.orient_to_refs # NextGenSeqUtils.orient_strands Function . orient_strands(seqs::Array{String}, phreds::Union{Array{Vector{Phred},1},Void}, names::Union{Array{String,1},Void}, ref::String; k::Int=6) Orients sequences (with phreds and names, which may be nothing ) relative to a reference sequence. k is kmer size for computing kmer vectors. source orient_strands(seqs::Array{String}, ref::String; k::Int=6) Orients sequences relative to a reference sequence. k is kmer size for computing kmer vectors. source orient_strands(seqs::Array{String,1}, phreds::Union{Array{Vector{Phred},1},Void}, names::Union{Array{String,1},Void}, ref::String, kmers::Array{Array{T,1},1}, ref_kmer::Array{T,1}, rev_ref_kmer::Array{T,1}) where {T : Real} Orients sequences with given kmer vectors relative to a reference sequence with given kmer vector. source # NextGenSeqUtils.orient_to_refs Function . orient_to_refs(seqs::Array{String,1}, phreds::Union{Array{Vector{Phred},1},Void}, names::Union{Array{String,1},Void}, refs::Array{String,1}; k::Int = 6) Orients each sequence in seqs to nearest reference sequence in panel of references ( refs ). Distance determined by amino acid similarity (kmer vector dot prod). source","title":"orient"},{"location":"orient/#sequence-orienting-functions","text":"NextGenSeqUtils.orient_strands NextGenSeqUtils.orient_to_refs # NextGenSeqUtils.orient_strands Function . orient_strands(seqs::Array{String}, phreds::Union{Array{Vector{Phred},1},Void}, names::Union{Array{String,1},Void}, ref::String; k::Int=6) Orients sequences (with phreds and names, which may be nothing ) relative to a reference sequence. k is kmer size for computing kmer vectors. source orient_strands(seqs::Array{String}, ref::String; k::Int=6) Orients sequences relative to a reference sequence. k is kmer size for computing kmer vectors. source orient_strands(seqs::Array{String,1}, phreds::Union{Array{Vector{Phred},1},Void}, names::Union{Array{String,1},Void}, ref::String, kmers::Array{Array{T,1},1}, ref_kmer::Array{T,1}, rev_ref_kmer::Array{T,1}) where {T : Real} Orients sequences with given kmer vectors relative to a reference sequence with given kmer vector. source # NextGenSeqUtils.orient_to_refs Function . orient_to_refs(seqs::Array{String,1}, phreds::Union{Array{Vector{Phred},1},Void}, names::Union{Array{String,1},Void}, refs::Array{String,1}; k::Int = 6) Orients each sequence in seqs to nearest reference sequence in panel of references ( refs ). Distance determined by amino acid similarity (kmer vector dot prod). source","title":"Sequence Orienting Functions"},{"location":"paths/","text":"USEARCH and MAFFT utilities NextGenSeqUtils.PATHS NextGenSeqUtils.Paths # NextGenSeqUtils.Paths Type . Datatype for holding usearch and mafft file paths source # NextGenSeqUtils.PATHS Constant . Default file paths. source","title":"paths"},{"location":"paths/#usearch-and-mafft-utilities","text":"NextGenSeqUtils.PATHS NextGenSeqUtils.Paths # NextGenSeqUtils.Paths Type . Datatype for holding usearch and mafft file paths source # NextGenSeqUtils.PATHS Constant . Default file paths. source","title":"USEARCH and MAFFT utilities"},{"location":"phreds/","text":"Phred / Probability Conversion Functions NextGenSeqUtils.error_probs_to_phreds NextGenSeqUtils.length_vs_qual NextGenSeqUtils.p_to_phred NextGenSeqUtils.phred_to_log_p NextGenSeqUtils.phred_to_p NextGenSeqUtils.qual_hist NextGenSeqUtils.quality_filter # NextGenSeqUtils.phred_to_log_p Function . phred_to_log_p(x) Conversion from phred value to log probability value. source # NextGenSeqUtils.phred_to_p Function . phred_to_p(q::Phred) Conversion from phred value to real probability value. source phred_to_p(x::Vector{Phred}) Conversion from phred values to real probability values in vector. source # NextGenSeqUtils.p_to_phred Function . p_to_phred(p::Prob) Conversion from real probability value to phred value. source p_to_phred(p::Prob) Conversion from real probability values to phred values in vector. source # NextGenSeqUtils.error_probs_to_phreds Function . error_probs_to_phreds(eps::Vector{Float64}) Conversion from error probability values to phred values in vector. source # NextGenSeqUtils.quality_filter Function . quality_filter(infile, outfile=join(split(infile, . )[1:end-1], . ) * .filt.fasta ; errorRate = 0.01, minLength = 100, labelPrefix = seq , errorOut = true) Writes file with sequences from input file that have all sites within error rate margin. source quality_filter(seqs::Array{String, 1}, scores::Array, names::Array{String, 1}; errorRate=0.01, minLength=0) Returns sub arrays with sequences that have site-wise error all within given margin. source # NextGenSeqUtils.length_vs_qual Function . length_vs_qual(fasta_path; plot_title = Length Vs Errors ) Creates plot of lengths of sequences vs. mean error rates of sequences. source # NextGenSeqUtils.qual_hist Function . qual_hist(fasta_path; plot_title = Quality Hist ) Creates histogram of mean quality scores per sequence. source","title":"phreds"},{"location":"phreds/#phred-probability-conversion-functions","text":"NextGenSeqUtils.error_probs_to_phreds NextGenSeqUtils.length_vs_qual NextGenSeqUtils.p_to_phred NextGenSeqUtils.phred_to_log_p NextGenSeqUtils.phred_to_p NextGenSeqUtils.qual_hist NextGenSeqUtils.quality_filter # NextGenSeqUtils.phred_to_log_p Function . phred_to_log_p(x) Conversion from phred value to log probability value. source # NextGenSeqUtils.phred_to_p Function . phred_to_p(q::Phred) Conversion from phred value to real probability value. source phred_to_p(x::Vector{Phred}) Conversion from phred values to real probability values in vector. source # NextGenSeqUtils.p_to_phred Function . p_to_phred(p::Prob) Conversion from real probability value to phred value. source p_to_phred(p::Prob) Conversion from real probability values to phred values in vector. source # NextGenSeqUtils.error_probs_to_phreds Function . error_probs_to_phreds(eps::Vector{Float64}) Conversion from error probability values to phred values in vector. source # NextGenSeqUtils.quality_filter Function . quality_filter(infile, outfile=join(split(infile, . )[1:end-1], . ) * .filt.fasta ; errorRate = 0.01, minLength = 100, labelPrefix = seq , errorOut = true) Writes file with sequences from input file that have all sites within error rate margin. source quality_filter(seqs::Array{String, 1}, scores::Array, names::Array{String, 1}; errorRate=0.01, minLength=0) Returns sub arrays with sequences that have site-wise error all within given margin. source # NextGenSeqUtils.length_vs_qual Function . length_vs_qual(fasta_path; plot_title = Length Vs Errors ) Creates plot of lengths of sequences vs. mean error rates of sequences. source # NextGenSeqUtils.qual_hist Function . qual_hist(fasta_path; plot_title = Quality Hist ) Creates histogram of mean quality scores per sequence. source","title":"Phred / Probability Conversion Functions"},{"location":"simulation/","text":"Sequencer Simulation Functions NextGenSeqUtils.env_pb_seq_sim NextGenSeqUtils.fixed_diff_evolve NextGenSeqUtils.pb_seq_sim NextGenSeqUtils.simple_evolve NextGenSeqUtils.simple_gen_seq # NextGenSeqUtils.simple_gen_seq Function . simple_gen_seq(n::Int) Generates a random uniform sequence of nucleotides. source # NextGenSeqUtils.simple_evolve Function . simple_evolve(refseq, err_rate) Evolves a sequence, uniformly. source # NextGenSeqUtils.fixed_diff_evolve Function . fixed_diff_evolve(template::String, n_diffs::Int64) Creates a fixed number of mutations of a sequence. source # NextGenSeqUtils.pb_seq_sim Function . pb_seq_sim(template::String, rate::Float64; with_qvs = false) Performs a sequence simulation from a template, specifying a target error rate, based on PacBio sequencing error model. source # NextGenSeqUtils.env_pb_seq_sim Function . env_pb_seq_sim(template::String, n::Int64; with_qvs = false) Simulated PacBio reads from amplicons that have envelope-like error profiles. source","title":"simulation"},{"location":"simulation/#sequencer-simulation-functions","text":"NextGenSeqUtils.env_pb_seq_sim NextGenSeqUtils.fixed_diff_evolve NextGenSeqUtils.pb_seq_sim NextGenSeqUtils.simple_evolve NextGenSeqUtils.simple_gen_seq # NextGenSeqUtils.simple_gen_seq Function . simple_gen_seq(n::Int) Generates a random uniform sequence of nucleotides. source # NextGenSeqUtils.simple_evolve Function . simple_evolve(refseq, err_rate) Evolves a sequence, uniformly. source # NextGenSeqUtils.fixed_diff_evolve Function . fixed_diff_evolve(template::String, n_diffs::Int64) Creates a fixed number of mutations of a sequence. source # NextGenSeqUtils.pb_seq_sim Function . pb_seq_sim(template::String, rate::Float64; with_qvs = false) Performs a sequence simulation from a template, specifying a target error rate, based on PacBio sequencing error model. source # NextGenSeqUtils.env_pb_seq_sim Function . env_pb_seq_sim(template::String, n::Int64; with_qvs = false) Simulated PacBio reads from amplicons that have envelope-like error profiles. source","title":"Sequencer Simulation Functions"},{"location":"utils/","text":"Utility and Misc. Functions BioSequences.reverse_complement NextGenSeqUtils.concat_fastas NextGenSeqUtils.dash_count NextGenSeqUtils.degap NextGenSeqUtils.filter_by_length NextGenSeqUtils.freq NextGenSeqUtils.freq_dict_print NextGenSeqUtils.generate_aa_seqs NextGenSeqUtils.length_filter NextGenSeqUtils.maxfreq NextGenSeqUtils.print_diffs NextGenSeqUtils.print_fasta NextGenSeqUtils.print_rgb NextGenSeqUtils.seq_details NextGenSeqUtils.single_gap NextGenSeqUtils.single_mod_three_gap NextGenSeqUtils.sorted_freqs NextGenSeqUtils.translate_to_aa NextGenSeqUtils.trim_ends_indices # NextGenSeqUtils.print_fasta Function . print_fasta(seqs, names) Prints fasta format to the terminal, for copypasting into alignment/blast etc. source # NextGenSeqUtils.degap Function . degap(s::String) Returns given string without '-' gap symbols. source degap(s::DNASequence) Returns given string without '-' gap symbols. source # NextGenSeqUtils.dash_count Function . dash_count(inStr::String) Counts number of gap symbols '-' in given string. source # NextGenSeqUtils.single_gap Function . single_gap(str::String, ind::Int) True if str has a single gap '-' at index ind , else false. source # NextGenSeqUtils.single_mod_three_gap Function . single_mod_three_gap(str::String, ind::Int) True if str has a gap length of 1 mod 3 at given index. source # NextGenSeqUtils.seq_details Function . seq_details(fasta_path) Gives names, sequences, error rates, and lengths from given filepath, which may end in '.fasta' or '.fastq'. source # NextGenSeqUtils.print_rgb Function . print_rgb(r, g, b, t) Prints in colors r , g , b to terminal. source # BioSequences.reverse_complement Function . reverse_complement(seq) Make a reversed complement sequence of seq . Ambiguous nucleotides are left as-is. source reverse_complement(kmer::Kmer) Return the reverse complement of kmer source reverse_complement(dna_string::String) Returns the complement of the reverse of given nucleotide sequence. source # NextGenSeqUtils.print_diffs Function . print_diffs(s1, s2; width=5, prefix= ) Prints two already aligned sequences with differences in color to terminal. source # NextGenSeqUtils.trim_ends_indices Function . trim_ends_indices(seq, ref; edge_reduction=0.1) Align seq to ref with default low penalties for gaps on ends, and trim insertions on the ends of seq . Returns (start, stop) indices. source # NextGenSeqUtils.translate_to_aa Function . translate_to_aa(s::String) Return amino acid string translation of nucleotide sequence using BioSequences conversion. source # NextGenSeqUtils.generate_aa_seqs Function . generate_aa_seqs(str::String) Return sequence translated to amino acids in each reading frame (returns three amino acid sequences). source # NextGenSeqUtils.filter_by_length Function . filter_by_length(args...) Deprecated. See length_filter . source # NextGenSeqUtils.length_filter Function . length_filter(seqs::Array{String, 1}, phreds::Union{Array{Vector{Phred},1},Void}, names::Union{Array{String,1},Void}, minlength::Int, maxlength::Int) Filter sequences and corresponding names and phreds (which may be nothing ) by length. source length_filter(seqs::Array{String, 1}, minlength::Int64, maxlength::Int64) Filter sequences by length. source # NextGenSeqUtils.concat_fastas Function . concat_fastas(filepaths::Array{String, 1}, outfile::String) Write contents of all given files to a single .fasta file. source # NextGenSeqUtils.maxfreq Function . maxfreq(vec) Return the frequency of the most common element in vec . source # NextGenSeqUtils.freq Function . freq(vec, elem) Return the frequency of given element in given array; if the element is not present, return 0.0. source # NextGenSeqUtils.sorted_freqs Function . sorted_freqs(vec) Return tuples of (freq, elem) of unique elements of vec in order of decreasing frequency. source # NextGenSeqUtils.freq_dict_print Function . freq_dict_print(dictin; thresh=0) Prints frequency:element of elements of dictin above given threshold, where dictin is a proportionmap of elements (see proportionmap in StatsBase). source","title":"utils"},{"location":"utils/#utility-and-misc-functions","text":"BioSequences.reverse_complement NextGenSeqUtils.concat_fastas NextGenSeqUtils.dash_count NextGenSeqUtils.degap NextGenSeqUtils.filter_by_length NextGenSeqUtils.freq NextGenSeqUtils.freq_dict_print NextGenSeqUtils.generate_aa_seqs NextGenSeqUtils.length_filter NextGenSeqUtils.maxfreq NextGenSeqUtils.print_diffs NextGenSeqUtils.print_fasta NextGenSeqUtils.print_rgb NextGenSeqUtils.seq_details NextGenSeqUtils.single_gap NextGenSeqUtils.single_mod_three_gap NextGenSeqUtils.sorted_freqs NextGenSeqUtils.translate_to_aa NextGenSeqUtils.trim_ends_indices # NextGenSeqUtils.print_fasta Function . print_fasta(seqs, names) Prints fasta format to the terminal, for copypasting into alignment/blast etc. source # NextGenSeqUtils.degap Function . degap(s::String) Returns given string without '-' gap symbols. source degap(s::DNASequence) Returns given string without '-' gap symbols. source # NextGenSeqUtils.dash_count Function . dash_count(inStr::String) Counts number of gap symbols '-' in given string. source # NextGenSeqUtils.single_gap Function . single_gap(str::String, ind::Int) True if str has a single gap '-' at index ind , else false. source # NextGenSeqUtils.single_mod_three_gap Function . single_mod_three_gap(str::String, ind::Int) True if str has a gap length of 1 mod 3 at given index. source # NextGenSeqUtils.seq_details Function . seq_details(fasta_path) Gives names, sequences, error rates, and lengths from given filepath, which may end in '.fasta' or '.fastq'. source # NextGenSeqUtils.print_rgb Function . print_rgb(r, g, b, t) Prints in colors r , g , b to terminal. source # BioSequences.reverse_complement Function . reverse_complement(seq) Make a reversed complement sequence of seq . Ambiguous nucleotides are left as-is. source reverse_complement(kmer::Kmer) Return the reverse complement of kmer source reverse_complement(dna_string::String) Returns the complement of the reverse of given nucleotide sequence. source # NextGenSeqUtils.print_diffs Function . print_diffs(s1, s2; width=5, prefix= ) Prints two already aligned sequences with differences in color to terminal. source # NextGenSeqUtils.trim_ends_indices Function . trim_ends_indices(seq, ref; edge_reduction=0.1) Align seq to ref with default low penalties for gaps on ends, and trim insertions on the ends of seq . Returns (start, stop) indices. source # NextGenSeqUtils.translate_to_aa Function . translate_to_aa(s::String) Return amino acid string translation of nucleotide sequence using BioSequences conversion. source # NextGenSeqUtils.generate_aa_seqs Function . generate_aa_seqs(str::String) Return sequence translated to amino acids in each reading frame (returns three amino acid sequences). source # NextGenSeqUtils.filter_by_length Function . filter_by_length(args...) Deprecated. See length_filter . source # NextGenSeqUtils.length_filter Function . length_filter(seqs::Array{String, 1}, phreds::Union{Array{Vector{Phred},1},Void}, names::Union{Array{String,1},Void}, minlength::Int, maxlength::Int) Filter sequences and corresponding names and phreds (which may be nothing ) by length. source length_filter(seqs::Array{String, 1}, minlength::Int64, maxlength::Int64) Filter sequences by length. source # NextGenSeqUtils.concat_fastas Function . concat_fastas(filepaths::Array{String, 1}, outfile::String) Write contents of all given files to a single .fasta file. source # NextGenSeqUtils.maxfreq Function . maxfreq(vec) Return the frequency of the most common element in vec . source # NextGenSeqUtils.freq Function . freq(vec, elem) Return the frequency of given element in given array; if the element is not present, return 0.0. source # NextGenSeqUtils.sorted_freqs Function . sorted_freqs(vec) Return tuples of (freq, elem) of unique elements of vec in order of decreasing frequency. source # NextGenSeqUtils.freq_dict_print Function . freq_dict_print(dictin; thresh=0) Prints frequency:element of elements of dictin above given threshold, where dictin is a proportionmap of elements (see proportionmap in StatsBase). source","title":"Utility and Misc. Functions"}]}