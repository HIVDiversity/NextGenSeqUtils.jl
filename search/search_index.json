{
    "docs": [
        {
            "location": "/", 
            "text": "", 
            "title": "Home"
        }, 
        {
            "location": "/align/", 
            "text": "Alignment Functions\n\n\n\n\nNextGenSeqUtils.align_reference_frames\n\n\nNextGenSeqUtils.banded_nw_align\n\n\nNextGenSeqUtils.kmer_seeded_align\n\n\nNextGenSeqUtils.kmer_seeded_edit_dist\n\n\nNextGenSeqUtils.loc_kmer_seeded_align\n\n\nNextGenSeqUtils.local_align\n\n\nNextGenSeqUtils.local_edit_dist\n\n\nNextGenSeqUtils.local_kmer_seeded_align\n\n\nNextGenSeqUtils.nw_align\n\n\nNextGenSeqUtils.resolve_alignments\n\n\nNextGenSeqUtils.triplet_kmer_seeded_align\n\n\nNextGenSeqUtils.triplet_nw_align\n\n\n\n\n#\n\n\nNextGenSeqUtils.nw_align\n \n \nFunction\n.\n\n\nnw_align(s1::String, s2::String; edge_reduction = 0.99)\n\n\n\n\nReturns aligned strings using the Needleman-Wunch Algorithm (quadratic),  with end gaps penalized slightly less. edge_reduction is a multiplier (usually less than one) on gaps on end of strings.\n\n\nsource\n\n\nnw_align(s1::String, s2::String, banded::Float64)\n\n\n\n\nWrapper for \nnw_align\n and \nbanded_nw_align\n. A larger \nbanded\n value makes alignment slower but more accurate.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.banded_nw_align\n \n \nFunction\n.\n\n\nbanded_nw_align(s1::String, s2::String; edge_reduction = 0.99, band_coeff = 1)\n\n\n\n\nLike nw_align, but sub quadratic by only computing values within a band around the center diagonal. One 'band' of radius 3 = (4,1), (3,1), (2,1), (1,1), (1,2), (1,3), (1,4), aka upside-down L shape. band_coeff = 1 is sufficient to get same alignments as nw_align for 10% diverged sequences ~97% of the time; increase this value for more conservative alignment with longer computation time. Radius of band = \nbandwidth\n = \nband_coeff\n * sqrt(avg seq length)\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.triplet_nw_align\n \n \nFunction\n.\n\n\ntriplet_nw_align(s1::String, s2::String; edge_reduction = 0.99, boundary_mult = 2)\n\n\n\n\nReturns alignment of two sequences where \ns1\n is a reference with reading frame to be preserved and \ns2\n is a query sequence. \nboundary_mult\n adjusts penalties for gaps preserving the reading frame of \ns1\n. This usually works best on range 0 to 3, higher values for more strongly enforced gaps aligned on  reference frame (divisible-by-3 indices)\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.local_align\n \n \nFunction\n.\n\n\nlocal_align(ref::String, query::String; mismatch_score = -1, \n            match_score = 1, gap_penalty = -1, \n            rightaligned=true, refend = false)\n\n\n\n\nAligns a query sequence locally to a reference. If true, \nrightaligned\n keeps the right ends of each sequence in final alignment- otherwise they are trimmed;  \nrefend\n keeps the beginning/left end of \nref\n.  If you want to keep both ends of both strings, use nw_align. For best alignments use the default score values.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.kmer_seeded_align\n \n \nFunction\n.\n\n\nkmer_seeded_align(s1::String, s2::String;\n                  wordlength = 30,\n                  skip = 10,\n                  aligncodons = false,\n                  banded = 1.0,\n                  debug::Bool = false)\n\n\n\n\nReturns aligned strings, where alignment is first done with larger word matches and  then (possibly banded) Needleman-Wunsch on intermediate intervals. \nskip\n gives a necessary gap between searched-for words in \ns1\n. For best results, use the default \nwordlength\n and \nskip\n values. See \nnw_align\n for explanation of \nbanded\n.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.triplet_kmer_seeded_align\n \n \nFunction\n.\n\n\ntriplet_kmer_seeded_align(s1::String, s2::String;\n                          wordlength = 30,\n                          skip = 9,\n                          boundary_mult = 2,\n                          alignedcodons = true,\n                          debug::Bool=false)\n\n\n\n\nReturns aligned strings, where alignment is first done with word matches and  then Needleman-Wunsch on intermediate intervals, prefering to preserve the  reading frame of the first arg \ns1\n. \nskip\n gives a necessary gap between searched-for words in \ns1\n. For best results, use the default \nwordlength\n and \nskip\n values. See \ntriplet_nw_align\n for explanation of \nboundary_mult\n.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.loc_kmer_seeded_align\n \n \nFunction\n.\n\n\nfunction local_kmer_seeded_align(s1::String, s2::String;\n                                 wordlength = 30,\n                                 skip = 10,\n                                 trimpadding = 100,\n                                 debug::Bool=false)\n\n\n\n\nReturns locally aligned strings, where alignment is first done with word matches and  then Needleman-Wunsch on intermediate intervals.\n\n\ns1\n is a reference to align to, and \ns2\n is a query to extract a local match from. \ns2\n may be trimmed or expanded with gaps. Before locally aligning ends of sequences, the ends of \ns2\n are trimmed to length \ntrimpadding\n for faster alignment. Increasing this will possible increase alignment accuracy but effect runtime. \nskip\n gives a necessary gap between searched-for words in \ns1\n. For best results, use the default \nwordlength\n and \nskip\n values.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.local_kmer_seeded_align\n \n \nFunction\n.\n\n\nfunction local_kmer_seeded_align(s1::String, s2::String;\n                                 wordlength = 30,\n                                 skip = 10,\n                                 trimpadding = 100,\n                                 debug::Bool=false)\n\n\n\n\nReturns locally aligned strings, where alignment is first done with word matches and  then Needleman-Wunsch on intermediate intervals.\n\n\ns1\n is a reference to align to, and \ns2\n is a query to extract a local match from. \ns2\n may be trimmed or expanded with gaps. Before locally aligning ends of sequences, the ends of \ns2\n are trimmed to length \ntrimpadding\n for faster alignment. Increasing this will possible increase alignment accuracy but effect runtime. \nskip\n gives a necessary gap between searched-for words in \ns1\n. For best results, use the default \nwordlength\n and \nskip\n values.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.kmer_seeded_edit_dist\n \n \nFunction\n.\n\n\nkmer_seeded_edit_dist(s1::String , s2::String;\n                      wordlength = 30,\n                      skip = 5,\n                      aa_matches = false)\n\n\n\n\nComputes levenshtein edit distance with speedups from only computing the dp scoring matrix between word matches. If aa_matches = true, will attempt to find amino acid matches in any reference frame,  and add the nucleotide Hamming distance of these matches to Levenshtein distances of mismatches. \nskip\n gives a necessary gap between searched-for words in \ns1\n. For best results, use the default \nwordlength\n and \nskip\n values.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.resolve_alignments\n \n \nFunction\n.\n\n\nresolve_alignments(ref::String, query::String; mode = 1)\n\n\n\n\nCalled on aligned strings. Resolves \nquery\n with respect to \nref\n.  \nmode\n = 1 for resolving single indels, \nmode\n = 2 for resolving single indels and codon insertions in query.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.align_reference_frames\n \n \nFunction\n.\n\n\nalign_reading_frames(clusters; k = 6, thresh = 0.03, verbose = false)\n\n\n\n\nTakes \nclusters\n = [consensus_sequences, cluster_sizes], chooses references out of consensuses that do not have stop codons in the middle, and makes all consensus sequence reading frames agree. Returns resolved consensus seqs (\ngoods\n) along with filtered out consensus seqs that are \nthresh\n divergent from nearest reference (\nbads\n). \nk\n = kmer size for computing kmer vectors of sequences.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.local_edit_dist\n \n \nFunction\n.\n\n\nlocal_edit_dist(s1::String, s2::String)\n\n\n\n\nReturns the edit distance between two sequences after local alignment\n\n\nsource", 
            "title": "Align"
        }, 
        {
            "location": "/align/#alignment-functions", 
            "text": "NextGenSeqUtils.align_reference_frames  NextGenSeqUtils.banded_nw_align  NextGenSeqUtils.kmer_seeded_align  NextGenSeqUtils.kmer_seeded_edit_dist  NextGenSeqUtils.loc_kmer_seeded_align  NextGenSeqUtils.local_align  NextGenSeqUtils.local_edit_dist  NextGenSeqUtils.local_kmer_seeded_align  NextGenSeqUtils.nw_align  NextGenSeqUtils.resolve_alignments  NextGenSeqUtils.triplet_kmer_seeded_align  NextGenSeqUtils.triplet_nw_align   #  NextGenSeqUtils.nw_align     Function .  nw_align(s1::String, s2::String; edge_reduction = 0.99)  Returns aligned strings using the Needleman-Wunch Algorithm (quadratic),  with end gaps penalized slightly less. edge_reduction is a multiplier (usually less than one) on gaps on end of strings.  source  nw_align(s1::String, s2::String, banded::Float64)  Wrapper for  nw_align  and  banded_nw_align . A larger  banded  value makes alignment slower but more accurate.  source  #  NextGenSeqUtils.banded_nw_align     Function .  banded_nw_align(s1::String, s2::String; edge_reduction = 0.99, band_coeff = 1)  Like nw_align, but sub quadratic by only computing values within a band around the center diagonal. One 'band' of radius 3 = (4,1), (3,1), (2,1), (1,1), (1,2), (1,3), (1,4), aka upside-down L shape. band_coeff = 1 is sufficient to get same alignments as nw_align for 10% diverged sequences ~97% of the time; increase this value for more conservative alignment with longer computation time. Radius of band =  bandwidth  =  band_coeff  * sqrt(avg seq length)  source  #  NextGenSeqUtils.triplet_nw_align     Function .  triplet_nw_align(s1::String, s2::String; edge_reduction = 0.99, boundary_mult = 2)  Returns alignment of two sequences where  s1  is a reference with reading frame to be preserved and  s2  is a query sequence.  boundary_mult  adjusts penalties for gaps preserving the reading frame of  s1 . This usually works best on range 0 to 3, higher values for more strongly enforced gaps aligned on  reference frame (divisible-by-3 indices)  source  #  NextGenSeqUtils.local_align     Function .  local_align(ref::String, query::String; mismatch_score = -1, \n            match_score = 1, gap_penalty = -1, \n            rightaligned=true, refend = false)  Aligns a query sequence locally to a reference. If true,  rightaligned  keeps the right ends of each sequence in final alignment- otherwise they are trimmed;   refend  keeps the beginning/left end of  ref .  If you want to keep both ends of both strings, use nw_align. For best alignments use the default score values.  source  #  NextGenSeqUtils.kmer_seeded_align     Function .  kmer_seeded_align(s1::String, s2::String;\n                  wordlength = 30,\n                  skip = 10,\n                  aligncodons = false,\n                  banded = 1.0,\n                  debug::Bool = false)  Returns aligned strings, where alignment is first done with larger word matches and  then (possibly banded) Needleman-Wunsch on intermediate intervals.  skip  gives a necessary gap between searched-for words in  s1 . For best results, use the default  wordlength  and  skip  values. See  nw_align  for explanation of  banded .  source  #  NextGenSeqUtils.triplet_kmer_seeded_align     Function .  triplet_kmer_seeded_align(s1::String, s2::String;\n                          wordlength = 30,\n                          skip = 9,\n                          boundary_mult = 2,\n                          alignedcodons = true,\n                          debug::Bool=false)  Returns aligned strings, where alignment is first done with word matches and  then Needleman-Wunsch on intermediate intervals, prefering to preserve the  reading frame of the first arg  s1 .  skip  gives a necessary gap between searched-for words in  s1 . For best results, use the default  wordlength  and  skip  values. See  triplet_nw_align  for explanation of  boundary_mult .  source  #  NextGenSeqUtils.loc_kmer_seeded_align     Function .  function local_kmer_seeded_align(s1::String, s2::String;\n                                 wordlength = 30,\n                                 skip = 10,\n                                 trimpadding = 100,\n                                 debug::Bool=false)  Returns locally aligned strings, where alignment is first done with word matches and  then Needleman-Wunsch on intermediate intervals.  s1  is a reference to align to, and  s2  is a query to extract a local match from.  s2  may be trimmed or expanded with gaps. Before locally aligning ends of sequences, the ends of  s2  are trimmed to length  trimpadding  for faster alignment. Increasing this will possible increase alignment accuracy but effect runtime.  skip  gives a necessary gap between searched-for words in  s1 . For best results, use the default  wordlength  and  skip  values.  source  #  NextGenSeqUtils.local_kmer_seeded_align     Function .  function local_kmer_seeded_align(s1::String, s2::String;\n                                 wordlength = 30,\n                                 skip = 10,\n                                 trimpadding = 100,\n                                 debug::Bool=false)  Returns locally aligned strings, where alignment is first done with word matches and  then Needleman-Wunsch on intermediate intervals.  s1  is a reference to align to, and  s2  is a query to extract a local match from.  s2  may be trimmed or expanded with gaps. Before locally aligning ends of sequences, the ends of  s2  are trimmed to length  trimpadding  for faster alignment. Increasing this will possible increase alignment accuracy but effect runtime.  skip  gives a necessary gap between searched-for words in  s1 . For best results, use the default  wordlength  and  skip  values.  source  #  NextGenSeqUtils.kmer_seeded_edit_dist     Function .  kmer_seeded_edit_dist(s1::String , s2::String;\n                      wordlength = 30,\n                      skip = 5,\n                      aa_matches = false)  Computes levenshtein edit distance with speedups from only computing the dp scoring matrix between word matches. If aa_matches = true, will attempt to find amino acid matches in any reference frame,  and add the nucleotide Hamming distance of these matches to Levenshtein distances of mismatches.  skip  gives a necessary gap between searched-for words in  s1 . For best results, use the default  wordlength  and  skip  values.  source  #  NextGenSeqUtils.resolve_alignments     Function .  resolve_alignments(ref::String, query::String; mode = 1)  Called on aligned strings. Resolves  query  with respect to  ref .   mode  = 1 for resolving single indels,  mode  = 2 for resolving single indels and codon insertions in query.  source  #  NextGenSeqUtils.align_reference_frames     Function .  align_reading_frames(clusters; k = 6, thresh = 0.03, verbose = false)  Takes  clusters  = [consensus_sequences, cluster_sizes], chooses references out of consensuses that do not have stop codons in the middle, and makes all consensus sequence reading frames agree. Returns resolved consensus seqs ( goods ) along with filtered out consensus seqs that are  thresh  divergent from nearest reference ( bads ).  k  = kmer size for computing kmer vectors of sequences.  source  #  NextGenSeqUtils.local_edit_dist     Function .  local_edit_dist(s1::String, s2::String)  Returns the edit distance between two sequences after local alignment  source", 
            "title": "Alignment Functions"
        }, 
        {
            "location": "/hmm/", 
            "text": "Hidden Markov Model Functions\n\n\n\n\nNextGenSeqUtils.backward_logs\n\n\nNextGenSeqUtils.forward_backward_logs\n\n\nNextGenSeqUtils.forward_logs\n\n\nNextGenSeqUtils.gen_seq_with_model\n\n\nNextGenSeqUtils.get_obs_given_state\n\n\nNextGenSeqUtils.homopolymer_filter\n\n\nNextGenSeqUtils.initial_dist\n\n\nNextGenSeqUtils.logsum\n\n\nNextGenSeqUtils.markov_filter\n\n\nNextGenSeqUtils.obs_mat\n\n\nNextGenSeqUtils.trans_mat\n\n\nNextGenSeqUtils.viterbi_logs\n\n\nNextGenSeqUtils.viterbiprint\n\n\n\n\n#\n\n\nNextGenSeqUtils.viterbi_logs\n \n \nFunction\n.\n\n\nviterbi_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64})\n\n\n\n\nReturn viterbi path and log probability for that path. Takes logs of matrices. \nobservations_given_states\n has # rows = # states, # columns = # steps of markov process.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.trans_mat\n \n \nFunction\n.\n\n\ntrans_mat(; uniform_cycle_prob = 0.9999999999, homopoly_cycle_prob = 0.98)\n\n\n\n\nReturn 5x5 transition matrix with given transition probabilities State 1 \u2013 uniform observation distribution. State 2 \u2013 High \"A\" observation likelihood. State 3 \u2013 High \"C\" observation likelihood. State 4 \u2013 High \"G\" observation likelihood. State 5 \u2013 High \"T\" observation likelihood. Each state has high likelihood to return to state 1. States 2 through 5 represent high likelihood of homopolymer regions of respective nuc.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.obs_mat\n \n \nFunction\n.\n\n\nobs_mat(; homopoly_prob = 0.99)\n\n\n\n\nReturn 5x4 observation matrix with given probabilities. State 1 \u2013 uniform observation distribution. State 2 \u2013 High \"A\" observation likelihood. State 3 \u2013 High \"C\" observation likelihood. State 4 \u2013 High \"G\" observation likelihood. State 5 \u2013 High \"T\" observation likelihood. Columns are in same order as columns 2 through 5 (the last four rows give a symmetric matrix).\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.initial_dist\n \n \nFunction\n.\n\n\ninitial_dist(; uniform_state = 0.99)\n\n\n\n\nInitial state distributions: see \ntrans_mat\n for state descriptions. 5x1 vector.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.get_obs_given_state\n \n \nFunction\n.\n\n\nget_obs_given_state(observation_matrix::Array{Float64,2}, observation_seq::String)\n\n\n\n\nPopulate 5xT matrix with likelihood of observation at each of T time steps given each  nucleotide in \nobservation_seq\n.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.homopolymer_filter\n \n \nFunction\n.\n\n\nhomopolymer_filter(seqs::Array{String,1}, phreds, names;\n                   transmat = nothing, obsmat = nothing,\n                   initialdist = nothing)\n\n\n\n\nFilter sequences with \"bad\" sections in the middle \u2013 abnormally long runs of a single base, using viterbi alg inference. If this homopolymer occurs on one end of a sequence, keeps sequence and trims homopolymer region off end. \nphreds\n and/or \nnames\n may be \nnothing\n, in which case \nnothing\n is returned for the respective field. If transition, observation, initial distribution matrices not provided (default) then the default values from the respective constructors are used.\n\n\nsource\n\n\nhomopolymer_filter(sourcepath::String, destpath::String;\n                   transmat = nothing, obsmat = nothing,\n                   initialdist = nothing, format=\nfastq\n)\n\n\n\n\nFilter sequences with \"bad\" sections in the middle \u2013 abnormally long runs of a single base, using viterbi alg inference. If this homopolymer occurs on one end of a sequence, keeps sequence and trims homopolymer region off end. Takes a file path for each of a source file of type \nformat\n (which may be \"fasta\" or \"fastq\") and a destination file is written which is the same file type.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.markov_filter\n \n \nFunction\n.\n\n\nhomopolymer_filter(seqs::Array{String,1}, phreds, names;\n                   transmat = nothing, obsmat = nothing,\n                   initialdist = nothing)\n\n\n\n\nFilter sequences with \"bad\" sections in the middle \u2013 abnormally long runs of a single base, using viterbi alg inference. If this homopolymer occurs on one end of a sequence, keeps sequence and trims homopolymer region off end. \nphreds\n and/or \nnames\n may be \nnothing\n, in which case \nnothing\n is returned for the respective field. If transition, observation, initial distribution matrices not provided (default) then the default values from the respective constructors are used.\n\n\nsource\n\n\nhomopolymer_filter(sourcepath::String, destpath::String;\n                   transmat = nothing, obsmat = nothing,\n                   initialdist = nothing, format=\nfastq\n)\n\n\n\n\nFilter sequences with \"bad\" sections in the middle \u2013 abnormally long runs of a single base, using viterbi alg inference. If this homopolymer occurs on one end of a sequence, keeps sequence and trims homopolymer region off end. Takes a file path for each of a source file of type \nformat\n (which may be \"fasta\" or \"fastq\") and a destination file is written which is the same file type.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.forward_logs\n \n \nFunction\n.\n\n\nforward_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64})\n\n\n\n\nCompute logs of forward scores. Takes logs of matrices as inputs. \nobservations_given_states\n has # rows = # states, # columns = # steps of markov process.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.backward_logs\n \n \nFunction\n.\n\n\nbackward_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64})\n\n\n\n\nCompute logs of backward scores and individual posterior probabilities. Takes logs of matrices as inputs. \nobservations_given_states\n has # rows = # states, # columns = # steps of markov process.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.forward_backward_logs\n \n \nFunction\n.\n\n\nforward_backward_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64})\n\n\n\n\nCompute logs of forward-backward scores and individual probabilities. Takes logs of matrices as inputs. \nobservations_given_states\n has # rows = # states, # columns = # steps of markov process.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.logsum\n \n \nFunction\n.\n\n\nlogsum(lga, lgb)\n\n\n\n\nCompute numerically stable logsum. Returns \n-Inf\n if either input is \n-Inf\n.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.gen_seq_with_model\n \n \nFunction\n.\n\n\ngen_seq_with_model(n::Int, trans_mat, obs_mat, initial_dists)\n\n\n\n\nGenerate a sequence given a markov model. May create bad reads (long runs of a single base).\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.viterbiprint\n \n \nFunction\n.\n\n\nviterbiprint(s::String)\n\n\n\n\nDraw flagged sites with capital letters, safe sites with lowercase.\n\n\nsource", 
            "title": "hmm"
        }, 
        {
            "location": "/hmm/#hidden-markov-model-functions", 
            "text": "NextGenSeqUtils.backward_logs  NextGenSeqUtils.forward_backward_logs  NextGenSeqUtils.forward_logs  NextGenSeqUtils.gen_seq_with_model  NextGenSeqUtils.get_obs_given_state  NextGenSeqUtils.homopolymer_filter  NextGenSeqUtils.initial_dist  NextGenSeqUtils.logsum  NextGenSeqUtils.markov_filter  NextGenSeqUtils.obs_mat  NextGenSeqUtils.trans_mat  NextGenSeqUtils.viterbi_logs  NextGenSeqUtils.viterbiprint   #  NextGenSeqUtils.viterbi_logs     Function .  viterbi_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64})  Return viterbi path and log probability for that path. Takes logs of matrices.  observations_given_states  has # rows = # states, # columns = # steps of markov process.  source  #  NextGenSeqUtils.trans_mat     Function .  trans_mat(; uniform_cycle_prob = 0.9999999999, homopoly_cycle_prob = 0.98)  Return 5x5 transition matrix with given transition probabilities State 1 \u2013 uniform observation distribution. State 2 \u2013 High \"A\" observation likelihood. State 3 \u2013 High \"C\" observation likelihood. State 4 \u2013 High \"G\" observation likelihood. State 5 \u2013 High \"T\" observation likelihood. Each state has high likelihood to return to state 1. States 2 through 5 represent high likelihood of homopolymer regions of respective nuc.  source  #  NextGenSeqUtils.obs_mat     Function .  obs_mat(; homopoly_prob = 0.99)  Return 5x4 observation matrix with given probabilities. State 1 \u2013 uniform observation distribution. State 2 \u2013 High \"A\" observation likelihood. State 3 \u2013 High \"C\" observation likelihood. State 4 \u2013 High \"G\" observation likelihood. State 5 \u2013 High \"T\" observation likelihood. Columns are in same order as columns 2 through 5 (the last four rows give a symmetric matrix).  source  #  NextGenSeqUtils.initial_dist     Function .  initial_dist(; uniform_state = 0.99)  Initial state distributions: see  trans_mat  for state descriptions. 5x1 vector.  source  #  NextGenSeqUtils.get_obs_given_state     Function .  get_obs_given_state(observation_matrix::Array{Float64,2}, observation_seq::String)  Populate 5xT matrix with likelihood of observation at each of T time steps given each  nucleotide in  observation_seq .  source  #  NextGenSeqUtils.homopolymer_filter     Function .  homopolymer_filter(seqs::Array{String,1}, phreds, names;\n                   transmat = nothing, obsmat = nothing,\n                   initialdist = nothing)  Filter sequences with \"bad\" sections in the middle \u2013 abnormally long runs of a single base, using viterbi alg inference. If this homopolymer occurs on one end of a sequence, keeps sequence and trims homopolymer region off end.  phreds  and/or  names  may be  nothing , in which case  nothing  is returned for the respective field. If transition, observation, initial distribution matrices not provided (default) then the default values from the respective constructors are used.  source  homopolymer_filter(sourcepath::String, destpath::String;\n                   transmat = nothing, obsmat = nothing,\n                   initialdist = nothing, format= fastq )  Filter sequences with \"bad\" sections in the middle \u2013 abnormally long runs of a single base, using viterbi alg inference. If this homopolymer occurs on one end of a sequence, keeps sequence and trims homopolymer region off end. Takes a file path for each of a source file of type  format  (which may be \"fasta\" or \"fastq\") and a destination file is written which is the same file type.  source  #  NextGenSeqUtils.markov_filter     Function .  homopolymer_filter(seqs::Array{String,1}, phreds, names;\n                   transmat = nothing, obsmat = nothing,\n                   initialdist = nothing)  Filter sequences with \"bad\" sections in the middle \u2013 abnormally long runs of a single base, using viterbi alg inference. If this homopolymer occurs on one end of a sequence, keeps sequence and trims homopolymer region off end.  phreds  and/or  names  may be  nothing , in which case  nothing  is returned for the respective field. If transition, observation, initial distribution matrices not provided (default) then the default values from the respective constructors are used.  source  homopolymer_filter(sourcepath::String, destpath::String;\n                   transmat = nothing, obsmat = nothing,\n                   initialdist = nothing, format= fastq )  Filter sequences with \"bad\" sections in the middle \u2013 abnormally long runs of a single base, using viterbi alg inference. If this homopolymer occurs on one end of a sequence, keeps sequence and trims homopolymer region off end. Takes a file path for each of a source file of type  format  (which may be \"fasta\" or \"fastq\") and a destination file is written which is the same file type.  source  #  NextGenSeqUtils.forward_logs     Function .  forward_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64})  Compute logs of forward scores. Takes logs of matrices as inputs.  observations_given_states  has # rows = # states, # columns = # steps of markov process.  source  #  NextGenSeqUtils.backward_logs     Function .  backward_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64})  Compute logs of backward scores and individual posterior probabilities. Takes logs of matrices as inputs.  observations_given_states  has # rows = # states, # columns = # steps of markov process.  source  #  NextGenSeqUtils.forward_backward_logs     Function .  forward_backward_logs(observations_given_states::Array{Float64, 2}, transitions::Array{Float64, 2}, initials::Array{Float64})  Compute logs of forward-backward scores and individual probabilities. Takes logs of matrices as inputs.  observations_given_states  has # rows = # states, # columns = # steps of markov process.  source  #  NextGenSeqUtils.logsum     Function .  logsum(lga, lgb)  Compute numerically stable logsum. Returns  -Inf  if either input is  -Inf .  source  #  NextGenSeqUtils.gen_seq_with_model     Function .  gen_seq_with_model(n::Int, trans_mat, obs_mat, initial_dists)  Generate a sequence given a markov model. May create bad reads (long runs of a single base).  source  #  NextGenSeqUtils.viterbiprint     Function .  viterbiprint(s::String)  Draw flagged sites with capital letters, safe sites with lowercase.  source", 
            "title": "Hidden Markov Model Functions"
        }, 
        {
            "location": "/io/", 
            "text": "IO Functions\n\n\n\n\nNextGenSeqUtils.read_fasta\n\n\nNextGenSeqUtils.read_fasta_with_names\n\n\nNextGenSeqUtils.read_fasta_with_names_in_other_order\n\n\nNextGenSeqUtils.read_fastq\n\n\nNextGenSeqUtils.write_fasta\n\n\nNextGenSeqUtils.write_fastq\n\n\n\n\n#\n\n\nNextGenSeqUtils.read_fasta\n \n \nFunction\n.\n\n\nread_fasta(filename; seqtype=String)\n\n\n\n\nRead .fasta file contents, parse, and return sequences as type \nseqtype\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.read_fasta_with_names\n \n \nFunction\n.\n\n\nread_fasta_with_names(filename; seqtype=String)\n\n\n\n\nRead .fasta file contents, parse, and return names and sequences as type \nseqtype\n.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.read_fasta_with_names_in_other_order\n \n \nFunction\n.\n\n\nread_fasta_with_names_in_other_order(filename; seqtype=String)\n\n\n\n\nRead .fasta file contents, parse, and return sequences as type \nseqtype\n with names. Now that's what I call convenience.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.write_fasta\n \n \nFunction\n.\n\n\nwrite_fasta(filename::String, seqs; names = String[])\n\n\n\n\nWrite given \nseqs\n and optional \nnames\n to a .fasta file with given filepath.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.read_fastq\n \n \nFunction\n.\n\n\nread_fastq(filename; seqtype=String)\n\n\n\n\nRead .fastq file contents, parse, and return sequences as \nseqtype\n type, phreds, and names.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.write_fastq\n \n \nFunction\n.\n\n\nwrite_fastq(filename, seqs, phreds::Vector{Vector{Phred}};\n                 names=String[], DNASeqType = false)\n\n\n\n\nWrite given sequences, phreds, names to .fastq file with given file path. If \nnames\n not provided, gives names 'seq_1', etc.\n\n\nsource", 
            "title": "io"
        }, 
        {
            "location": "/io/#io-functions", 
            "text": "NextGenSeqUtils.read_fasta  NextGenSeqUtils.read_fasta_with_names  NextGenSeqUtils.read_fasta_with_names_in_other_order  NextGenSeqUtils.read_fastq  NextGenSeqUtils.write_fasta  NextGenSeqUtils.write_fastq   #  NextGenSeqUtils.read_fasta     Function .  read_fasta(filename; seqtype=String)  Read .fasta file contents, parse, and return sequences as type  seqtype  source  #  NextGenSeqUtils.read_fasta_with_names     Function .  read_fasta_with_names(filename; seqtype=String)  Read .fasta file contents, parse, and return names and sequences as type  seqtype .  source  #  NextGenSeqUtils.read_fasta_with_names_in_other_order     Function .  read_fasta_with_names_in_other_order(filename; seqtype=String)  Read .fasta file contents, parse, and return sequences as type  seqtype  with names. Now that's what I call convenience.  source  #  NextGenSeqUtils.write_fasta     Function .  write_fasta(filename::String, seqs; names = String[])  Write given  seqs  and optional  names  to a .fasta file with given filepath.  source  #  NextGenSeqUtils.read_fastq     Function .  read_fastq(filename; seqtype=String)  Read .fastq file contents, parse, and return sequences as  seqtype  type, phreds, and names.  source  #  NextGenSeqUtils.write_fastq     Function .  write_fastq(filename, seqs, phreds::Vector{Vector{Phred}};\n                 names=String[], DNASeqType = false)  Write given sequences, phreds, names to .fastq file with given file path. If  names  not provided, gives names 'seq_1', etc.  source", 
            "title": "IO Functions"
        }, 
        {
            "location": "/kmers/", 
            "text": "Kmer Vector Functions\n\n\n\n\nNextGenSeqUtils.corrected_kmer_dist\n\n\nNextGenSeqUtils.kmer_count\n\n\nNextGenSeqUtils.sparse_aa_kmer_count\n\n\n\n\n#\n\n\nNextGenSeqUtils.kmer_count\n \n \nFunction\n.\n\n\nkmer_count(str::String, k::Int)\n\n\n\n\nCount kmers of size \nk\n in string, return array with bins from \"A...A\" to \"T...T\" and value in each bin corresponding to number of occurences of that kmer within \nstr\n.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.sparse_aa_kmer_count\n \n \nFunction\n.\n\n\nsparse_aa_kmer_count(str::String, k::Int)\n\n\n\n\nCounts amino acid kmers in string (in all reading frames). k = length of kmer in amino acids. This is sparse and kinda slow.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.corrected_kmer_dist\n \n \nFunction\n.\n\n\ncorrected_kmer_dist(kmers1::Array, kmers2::Array; k = nothing)\n\n\n\n\nCompute distance between kmer vectors that is corrected towards edit distance for small differences. The default for \nk\n is \nk = Int(log(4, length(kmers1)))\n\n\nsource\n\n\ncorrected_kmer_dist(k::Int)\n\n\n\n\nReturns function that computes distance between \nk\n-mer vectors  that is corrected towards edit distance for small differences.\n\n\nsource", 
            "title": "kmers"
        }, 
        {
            "location": "/kmers/#kmer-vector-functions", 
            "text": "NextGenSeqUtils.corrected_kmer_dist  NextGenSeqUtils.kmer_count  NextGenSeqUtils.sparse_aa_kmer_count   #  NextGenSeqUtils.kmer_count     Function .  kmer_count(str::String, k::Int)  Count kmers of size  k  in string, return array with bins from \"A...A\" to \"T...T\" and value in each bin corresponding to number of occurences of that kmer within  str .  source  #  NextGenSeqUtils.sparse_aa_kmer_count     Function .  sparse_aa_kmer_count(str::String, k::Int)  Counts amino acid kmers in string (in all reading frames). k = length of kmer in amino acids. This is sparse and kinda slow.  source  #  NextGenSeqUtils.corrected_kmer_dist     Function .  corrected_kmer_dist(kmers1::Array, kmers2::Array; k = nothing)  Compute distance between kmer vectors that is corrected towards edit distance for small differences. The default for  k  is  k = Int(log(4, length(kmers1)))  source  corrected_kmer_dist(k::Int)  Returns function that computes distance between  k -mer vectors  that is corrected towards edit distance for small differences.  source", 
            "title": "Kmer Vector Functions"
        }, 
        {
            "location": "/orient/", 
            "text": "Sequence Orienting Functions\n\n\n\n\nNextGenSeqUtils.orient_strands\n\n\nNextGenSeqUtils.orient_to_refs\n\n\n\n\n#\n\n\nNextGenSeqUtils.orient_strands\n \n \nFunction\n.\n\n\norient_strands(seqs::Array{String}, phreds::Union{Array{Vector{Phred},1},Void}, \n               names::Union{Array{String,1},Void}, ref::String; k::Int=6)\n\n\n\n\nOrients sequences (with phreds and names, which may be \nnothing\n) relative to a reference sequence. \nk\n is kmer size for computing kmer vectors.\n\n\nsource\n\n\norient_strands(seqs::Array{String}, ref::String; k::Int=6)\n\n\n\n\nOrients sequences relative to a reference sequence. \nk\n is kmer size for computing kmer vectors.\n\n\nsource\n\n\norient_strands(seqs::Array{String,1}, phreds::Union{Array{Vector{Phred},1},Void}, names::Union{Array{String,1},Void}, \n                    ref::String, kmers::Array{Array{T,1},1}, ref_kmer::Array{T,1}, rev_ref_kmer::Array{T,1}) where {T \n: Real}\n\n\n\n\nOrients sequences with given kmer vectors relative to a reference sequence with given kmer vector.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.orient_to_refs\n \n \nFunction\n.\n\n\norient_to_refs(seqs::Array{String,1}, phreds::Union{Array{Vector{Phred},1},Void}, \n               names::Union{Array{String,1},Void}, refs::Array{String,1}; k::Int = 6)\n\n\n\n\nOrients each sequence in \nseqs\n to nearest reference sequence in panel of references (\nrefs\n). Distance determined by amino acid similarity (kmer vector dot prod).\n\n\nsource", 
            "title": "orient"
        }, 
        {
            "location": "/orient/#sequence-orienting-functions", 
            "text": "NextGenSeqUtils.orient_strands  NextGenSeqUtils.orient_to_refs   #  NextGenSeqUtils.orient_strands     Function .  orient_strands(seqs::Array{String}, phreds::Union{Array{Vector{Phred},1},Void}, \n               names::Union{Array{String,1},Void}, ref::String; k::Int=6)  Orients sequences (with phreds and names, which may be  nothing ) relative to a reference sequence.  k  is kmer size for computing kmer vectors.  source  orient_strands(seqs::Array{String}, ref::String; k::Int=6)  Orients sequences relative to a reference sequence.  k  is kmer size for computing kmer vectors.  source  orient_strands(seqs::Array{String,1}, phreds::Union{Array{Vector{Phred},1},Void}, names::Union{Array{String,1},Void}, \n                    ref::String, kmers::Array{Array{T,1},1}, ref_kmer::Array{T,1}, rev_ref_kmer::Array{T,1}) where {T  : Real}  Orients sequences with given kmer vectors relative to a reference sequence with given kmer vector.  source  #  NextGenSeqUtils.orient_to_refs     Function .  orient_to_refs(seqs::Array{String,1}, phreds::Union{Array{Vector{Phred},1},Void}, \n               names::Union{Array{String,1},Void}, refs::Array{String,1}; k::Int = 6)  Orients each sequence in  seqs  to nearest reference sequence in panel of references ( refs ). Distance determined by amino acid similarity (kmer vector dot prod).  source", 
            "title": "Sequence Orienting Functions"
        }, 
        {
            "location": "/paths/", 
            "text": "USEARCH and MAFFT utilities\n\n\n\n\nNextGenSeqUtils.PATHS\n\n\nNextGenSeqUtils.Paths\n\n\n\n\n#\n\n\nNextGenSeqUtils.Paths\n \n \nType\n.\n\n\nDatatype for holding usearch and mafft file paths\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.PATHS\n \n \nConstant\n.\n\n\nDefault file paths.\n\n\nsource", 
            "title": "paths"
        }, 
        {
            "location": "/paths/#usearch-and-mafft-utilities", 
            "text": "NextGenSeqUtils.PATHS  NextGenSeqUtils.Paths   #  NextGenSeqUtils.Paths     Type .  Datatype for holding usearch and mafft file paths  source  #  NextGenSeqUtils.PATHS     Constant .  Default file paths.  source", 
            "title": "USEARCH and MAFFT utilities"
        }, 
        {
            "location": "/phreds/", 
            "text": "Phred / Probability Conversion Functions\n\n\n\n\nNextGenSeqUtils.error_probs_to_phreds\n\n\nNextGenSeqUtils.length_vs_qual\n\n\nNextGenSeqUtils.p_to_phred\n\n\nNextGenSeqUtils.phred_to_log_p\n\n\nNextGenSeqUtils.phred_to_p\n\n\nNextGenSeqUtils.qual_hist\n\n\nNextGenSeqUtils.quality_filter\n\n\n\n\n#\n\n\nNextGenSeqUtils.phred_to_log_p\n \n \nFunction\n.\n\n\nphred_to_log_p(x)\n\n\n\n\nConversion from phred value to log probability value.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.phred_to_p\n \n \nFunction\n.\n\n\nphred_to_p(q::Phred)\n\n\n\n\nConversion from phred value to real probability value.\n\n\nsource\n\n\nphred_to_p(x::Vector{Phred})\n\n\n\n\nConversion from phred values to real probability values in vector.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.p_to_phred\n \n \nFunction\n.\n\n\np_to_phred(p::Prob)\n\n\n\n\nConversion from real probability value to phred value.\n\n\nsource\n\n\np_to_phred(p::Prob)\n\n\n\n\nConversion from real probability values to phred values in vector.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.error_probs_to_phreds\n \n \nFunction\n.\n\n\nerror_probs_to_phreds(eps::Vector{Float64})\n\n\n\n\nConversion from error probability values to phred values in vector.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.quality_filter\n \n \nFunction\n.\n\n\nquality_filter(infile, outfile=join(split(infile, \n.\n)[1:end-1], \n.\n) * \n.filt.fasta\n; \n               errorRate = 0.01, minLength = 100, labelPrefix = \nseq\n, errorOut = true)\n\n\n\n\nWrites file with sequences from input file that have all sites within error rate margin.\n\n\nsource\n\n\nquality_filter(seqs::Array{String, 1}, scores::Array, names::Array{String, 1}; errorRate=0.01, minLength=0)\n\n\n\n\nReturns sub arrays with sequences that have site-wise error all within given margin.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.length_vs_qual\n \n \nFunction\n.\n\n\nlength_vs_qual(fasta_path; plot_title = \nLength Vs Errors\n)\n\n\n\n\nCreates plot of lengths of sequences vs. mean error rates of sequences.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.qual_hist\n \n \nFunction\n.\n\n\nqual_hist(fasta_path; plot_title = \nQuality Hist\n)\n\n\n\n\nCreates histogram of mean quality scores per sequence.\n\n\nsource", 
            "title": "phreds"
        }, 
        {
            "location": "/phreds/#phred-probability-conversion-functions", 
            "text": "NextGenSeqUtils.error_probs_to_phreds  NextGenSeqUtils.length_vs_qual  NextGenSeqUtils.p_to_phred  NextGenSeqUtils.phred_to_log_p  NextGenSeqUtils.phred_to_p  NextGenSeqUtils.qual_hist  NextGenSeqUtils.quality_filter   #  NextGenSeqUtils.phred_to_log_p     Function .  phred_to_log_p(x)  Conversion from phred value to log probability value.  source  #  NextGenSeqUtils.phred_to_p     Function .  phred_to_p(q::Phred)  Conversion from phred value to real probability value.  source  phred_to_p(x::Vector{Phred})  Conversion from phred values to real probability values in vector.  source  #  NextGenSeqUtils.p_to_phred     Function .  p_to_phred(p::Prob)  Conversion from real probability value to phred value.  source  p_to_phred(p::Prob)  Conversion from real probability values to phred values in vector.  source  #  NextGenSeqUtils.error_probs_to_phreds     Function .  error_probs_to_phreds(eps::Vector{Float64})  Conversion from error probability values to phred values in vector.  source  #  NextGenSeqUtils.quality_filter     Function .  quality_filter(infile, outfile=join(split(infile,  . )[1:end-1],  . ) *  .filt.fasta ; \n               errorRate = 0.01, minLength = 100, labelPrefix =  seq , errorOut = true)  Writes file with sequences from input file that have all sites within error rate margin.  source  quality_filter(seqs::Array{String, 1}, scores::Array, names::Array{String, 1}; errorRate=0.01, minLength=0)  Returns sub arrays with sequences that have site-wise error all within given margin.  source  #  NextGenSeqUtils.length_vs_qual     Function .  length_vs_qual(fasta_path; plot_title =  Length Vs Errors )  Creates plot of lengths of sequences vs. mean error rates of sequences.  source  #  NextGenSeqUtils.qual_hist     Function .  qual_hist(fasta_path; plot_title =  Quality Hist )  Creates histogram of mean quality scores per sequence.  source", 
            "title": "Phred / Probability Conversion Functions"
        }, 
        {
            "location": "/simulation/", 
            "text": "Sequencer Simulation Functions\n\n\n\n\nNextGenSeqUtils.env_pb_seq_sim\n\n\nNextGenSeqUtils.fixed_diff_evolve\n\n\nNextGenSeqUtils.pb_seq_sim\n\n\nNextGenSeqUtils.simple_evolve\n\n\nNextGenSeqUtils.simple_gen_seq\n\n\n\n\n#\n\n\nNextGenSeqUtils.simple_gen_seq\n \n \nFunction\n.\n\n\nsimple_gen_seq(n::Int)\n\n\n\n\nGenerates a random uniform sequence of nucleotides.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.simple_evolve\n \n \nFunction\n.\n\n\nsimple_evolve(refseq, err_rate)\n\n\n\n\nEvolves a sequence, uniformly.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.fixed_diff_evolve\n \n \nFunction\n.\n\n\nfixed_diff_evolve(template::String, n_diffs::Int64)\n\n\n\n\nCreates a fixed number of mutations of a sequence.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.pb_seq_sim\n \n \nFunction\n.\n\n\npb_seq_sim(template::String, rate::Float64; with_qvs = false)\n\n\n\n\nPerforms a sequence simulation from a template, specifying a target error rate, based on PacBio sequencing error model.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.env_pb_seq_sim\n \n \nFunction\n.\n\n\nenv_pb_seq_sim(template::String, n::Int64; with_qvs = false)\n\n\n\n\nSimulated PacBio reads from amplicons that have envelope-like error profiles.\n\n\nsource", 
            "title": "simulation"
        }, 
        {
            "location": "/simulation/#sequencer-simulation-functions", 
            "text": "NextGenSeqUtils.env_pb_seq_sim  NextGenSeqUtils.fixed_diff_evolve  NextGenSeqUtils.pb_seq_sim  NextGenSeqUtils.simple_evolve  NextGenSeqUtils.simple_gen_seq   #  NextGenSeqUtils.simple_gen_seq     Function .  simple_gen_seq(n::Int)  Generates a random uniform sequence of nucleotides.  source  #  NextGenSeqUtils.simple_evolve     Function .  simple_evolve(refseq, err_rate)  Evolves a sequence, uniformly.  source  #  NextGenSeqUtils.fixed_diff_evolve     Function .  fixed_diff_evolve(template::String, n_diffs::Int64)  Creates a fixed number of mutations of a sequence.  source  #  NextGenSeqUtils.pb_seq_sim     Function .  pb_seq_sim(template::String, rate::Float64; with_qvs = false)  Performs a sequence simulation from a template, specifying a target error rate, based on PacBio sequencing error model.  source  #  NextGenSeqUtils.env_pb_seq_sim     Function .  env_pb_seq_sim(template::String, n::Int64; with_qvs = false)  Simulated PacBio reads from amplicons that have envelope-like error profiles.  source", 
            "title": "Sequencer Simulation Functions"
        }, 
        {
            "location": "/utils/", 
            "text": "Utility and Misc. Functions\n\n\n\n\nBioSequences.reverse_complement\n\n\nNextGenSeqUtils.concat_fastas\n\n\nNextGenSeqUtils.dash_count\n\n\nNextGenSeqUtils.degap\n\n\nNextGenSeqUtils.filter_by_length\n\n\nNextGenSeqUtils.freq\n\n\nNextGenSeqUtils.freq_dict_print\n\n\nNextGenSeqUtils.generate_aa_seqs\n\n\nNextGenSeqUtils.length_filter\n\n\nNextGenSeqUtils.maxfreq\n\n\nNextGenSeqUtils.print_diffs\n\n\nNextGenSeqUtils.print_fasta\n\n\nNextGenSeqUtils.print_rgb\n\n\nNextGenSeqUtils.seq_details\n\n\nNextGenSeqUtils.single_gap\n\n\nNextGenSeqUtils.single_mod_three_gap\n\n\nNextGenSeqUtils.sorted_freqs\n\n\nNextGenSeqUtils.translate_to_aa\n\n\nNextGenSeqUtils.trim_ends_indices\n\n\n\n\n#\n\n\nNextGenSeqUtils.print_fasta\n \n \nFunction\n.\n\n\nprint_fasta(seqs, names)\n\n\n\n\nPrints fasta format to the terminal, for copypasting into alignment/blast etc.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.degap\n \n \nFunction\n.\n\n\ndegap(s::String)\n\n\n\n\nReturns given string without '-' gap symbols.\n\n\nsource\n\n\ndegap(s::DNASequence)\n\n\n\n\nReturns given string without '-' gap symbols.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.dash_count\n \n \nFunction\n.\n\n\ndash_count(inStr::String)\n\n\n\n\nCounts number of gap symbols '-' in given string.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.single_gap\n \n \nFunction\n.\n\n\nsingle_gap(str::String, ind::Int)\n\n\n\n\nTrue if \nstr\n has a single gap '-' at index \nind\n, else false.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.single_mod_three_gap\n \n \nFunction\n.\n\n\nsingle_mod_three_gap(str::String, ind::Int)\n\n\n\n\nTrue if \nstr\n has a gap length of 1 mod 3 at given index.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.seq_details\n \n \nFunction\n.\n\n\nseq_details(fasta_path)\n\n\n\n\nGives names, sequences, error rates, and lengths from given filepath, which may end in '.fasta' or '.fastq'.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.print_rgb\n \n \nFunction\n.\n\n\nprint_rgb(r, g, b, t)\n\n\n\n\nPrints in colors \nr\n,\ng\n,\nb\n to terminal.\n\n\nsource\n\n\n#\n\n\nBioSequences.reverse_complement\n \n \nFunction\n.\n\n\nreverse_complement(seq)\n\n\n\n\nMake a reversed complement sequence of \nseq\n.\n\n\nAmbiguous nucleotides are left as-is.\n\n\nsource\n\n\nreverse_complement(kmer::Kmer)\n\n\n\n\nReturn the reverse complement of \nkmer\n\n\nsource\n\n\nreverse_complement(dna_string::String)\n\n\n\n\nReturns the complement of the reverse of given nucleotide sequence.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.print_diffs\n \n \nFunction\n.\n\n\nprint_diffs(s1, s2; width=5, prefix=\n)\n\n\n\n\nPrints two already aligned sequences with differences in color to terminal.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.trim_ends_indices\n \n \nFunction\n.\n\n\ntrim_ends_indices(seq, ref; edge_reduction=0.1)\n\n\n\n\nAlign \nseq\n to \nref\n with default low penalties for gaps on ends,  and trim insertions on the ends of \nseq\n.  Returns (start, stop) indices.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.translate_to_aa\n \n \nFunction\n.\n\n\ntranslate_to_aa(s::String)\n\n\n\n\nReturn amino acid string translation of nucleotide sequence using BioSequences conversion.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.generate_aa_seqs\n \n \nFunction\n.\n\n\ngenerate_aa_seqs(str::String)\n\n\n\n\nReturn sequence translated to amino acids in each reading frame (returns three amino acid sequences).\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.filter_by_length\n \n \nFunction\n.\n\n\nfilter_by_length(args...)\n\n\n\n\nDeprecated. See \nlength_filter\n.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.length_filter\n \n \nFunction\n.\n\n\nlength_filter(seqs::Array{String, 1}, phreds::Union{Array{Vector{Phred},1},Void}, names::Union{Array{String,1},Void},\n              minlength::Int, maxlength::Int)\n\n\n\n\nFilter sequences and corresponding names and phreds (which may be \nnothing\n) by length.\n\n\nsource\n\n\nlength_filter(seqs::Array{String, 1}, minlength::Int64, maxlength::Int64)\n\n\n\n\nFilter sequences by length.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.concat_fastas\n \n \nFunction\n.\n\n\nconcat_fastas(filepaths::Array{String, 1}, outfile::String)\n\n\n\n\nWrite contents of all given files to a single .fasta file.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.maxfreq\n \n \nFunction\n.\n\n\nmaxfreq(vec)\n\n\n\n\nReturn the frequency of the most common element in \nvec\n.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.freq\n \n \nFunction\n.\n\n\nfreq(vec, elem)\n\n\n\n\nReturn the frequency of given element in given array;  if the element is not present, return 0.0.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.sorted_freqs\n \n \nFunction\n.\n\n\nsorted_freqs(vec)\n\n\n\n\nReturn tuples of (freq, elem) of unique elements of \nvec\n  in order of decreasing frequency.\n\n\nsource\n\n\n#\n\n\nNextGenSeqUtils.freq_dict_print\n \n \nFunction\n.\n\n\nfreq_dict_print(dictin; thresh=0)\n\n\n\n\nPrints frequency:element of elements of \ndictin\n above given threshold,  where \ndictin\n is a proportionmap of elements (see \nproportionmap\n in StatsBase).\n\n\nsource", 
            "title": "utils"
        }, 
        {
            "location": "/utils/#utility-and-misc-functions", 
            "text": "BioSequences.reverse_complement  NextGenSeqUtils.concat_fastas  NextGenSeqUtils.dash_count  NextGenSeqUtils.degap  NextGenSeqUtils.filter_by_length  NextGenSeqUtils.freq  NextGenSeqUtils.freq_dict_print  NextGenSeqUtils.generate_aa_seqs  NextGenSeqUtils.length_filter  NextGenSeqUtils.maxfreq  NextGenSeqUtils.print_diffs  NextGenSeqUtils.print_fasta  NextGenSeqUtils.print_rgb  NextGenSeqUtils.seq_details  NextGenSeqUtils.single_gap  NextGenSeqUtils.single_mod_three_gap  NextGenSeqUtils.sorted_freqs  NextGenSeqUtils.translate_to_aa  NextGenSeqUtils.trim_ends_indices   #  NextGenSeqUtils.print_fasta     Function .  print_fasta(seqs, names)  Prints fasta format to the terminal, for copypasting into alignment/blast etc.  source  #  NextGenSeqUtils.degap     Function .  degap(s::String)  Returns given string without '-' gap symbols.  source  degap(s::DNASequence)  Returns given string without '-' gap symbols.  source  #  NextGenSeqUtils.dash_count     Function .  dash_count(inStr::String)  Counts number of gap symbols '-' in given string.  source  #  NextGenSeqUtils.single_gap     Function .  single_gap(str::String, ind::Int)  True if  str  has a single gap '-' at index  ind , else false.  source  #  NextGenSeqUtils.single_mod_three_gap     Function .  single_mod_three_gap(str::String, ind::Int)  True if  str  has a gap length of 1 mod 3 at given index.  source  #  NextGenSeqUtils.seq_details     Function .  seq_details(fasta_path)  Gives names, sequences, error rates, and lengths from given filepath, which may end in '.fasta' or '.fastq'.  source  #  NextGenSeqUtils.print_rgb     Function .  print_rgb(r, g, b, t)  Prints in colors  r , g , b  to terminal.  source  #  BioSequences.reverse_complement     Function .  reverse_complement(seq)  Make a reversed complement sequence of  seq .  Ambiguous nucleotides are left as-is.  source  reverse_complement(kmer::Kmer)  Return the reverse complement of  kmer  source  reverse_complement(dna_string::String)  Returns the complement of the reverse of given nucleotide sequence.  source  #  NextGenSeqUtils.print_diffs     Function .  print_diffs(s1, s2; width=5, prefix= )  Prints two already aligned sequences with differences in color to terminal.  source  #  NextGenSeqUtils.trim_ends_indices     Function .  trim_ends_indices(seq, ref; edge_reduction=0.1)  Align  seq  to  ref  with default low penalties for gaps on ends,  and trim insertions on the ends of  seq .  Returns (start, stop) indices.  source  #  NextGenSeqUtils.translate_to_aa     Function .  translate_to_aa(s::String)  Return amino acid string translation of nucleotide sequence using BioSequences conversion.  source  #  NextGenSeqUtils.generate_aa_seqs     Function .  generate_aa_seqs(str::String)  Return sequence translated to amino acids in each reading frame (returns three amino acid sequences).  source  #  NextGenSeqUtils.filter_by_length     Function .  filter_by_length(args...)  Deprecated. See  length_filter .  source  #  NextGenSeqUtils.length_filter     Function .  length_filter(seqs::Array{String, 1}, phreds::Union{Array{Vector{Phred},1},Void}, names::Union{Array{String,1},Void},\n              minlength::Int, maxlength::Int)  Filter sequences and corresponding names and phreds (which may be  nothing ) by length.  source  length_filter(seqs::Array{String, 1}, minlength::Int64, maxlength::Int64)  Filter sequences by length.  source  #  NextGenSeqUtils.concat_fastas     Function .  concat_fastas(filepaths::Array{String, 1}, outfile::String)  Write contents of all given files to a single .fasta file.  source  #  NextGenSeqUtils.maxfreq     Function .  maxfreq(vec)  Return the frequency of the most common element in  vec .  source  #  NextGenSeqUtils.freq     Function .  freq(vec, elem)  Return the frequency of given element in given array;  if the element is not present, return 0.0.  source  #  NextGenSeqUtils.sorted_freqs     Function .  sorted_freqs(vec)  Return tuples of (freq, elem) of unique elements of  vec   in order of decreasing frequency.  source  #  NextGenSeqUtils.freq_dict_print     Function .  freq_dict_print(dictin; thresh=0)  Prints frequency:element of elements of  dictin  above given threshold,  where  dictin  is a proportionmap of elements (see  proportionmap  in StatsBase).  source", 
            "title": "Utility and Misc. Functions"
        }
    ]
}